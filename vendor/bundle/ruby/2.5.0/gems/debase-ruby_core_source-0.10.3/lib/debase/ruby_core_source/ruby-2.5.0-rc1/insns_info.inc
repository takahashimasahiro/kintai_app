/** -*-c-*-
  This file contains instruction information for yarv instruction sequence.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit 'template/insns_info.inc.tmpl'
  or tool/insns2vm.rb
 */

#define TS_OFFSET 'O'
#define TS_NUM 'N'
#define TS_LINDEX 'L'
#define TS_VALUE 'V'
#define TS_ID 'I'
#define TS_GENTRY 'G'
#define TS_IC 'K'
#define TS_CALLINFO 'C'
#define TS_CALLCACHE 'E'
#define TS_CDHASH 'H'
#define TS_ISEQ 'S'
#define TS_VARIABLE '.'
#define TS_FUNCPTR 'F'

static const unsigned short insn_name_info_offset[] = {
    0,
    4,
    13,
    22,
    36,
    50,
    61,
    72,
    92,
    112,
    129,
    146,
    158,
    170,
    180,
    190,
    197,
    205,
    215,
    232,
    240,
    250,
    264,
    273,
    286,
    295,
    302,
    311,
    320,
    332,
    344,
    355,
    363,
    372,
    376,
    380,
    385,
    390,
    398,
    404,
    409,
    414,
    426,
    434,
    445,
    458,
    470,
    482,
    487,
    502,
    517,
    534,
    551,
    574,
    586,
    598,
    604,
    610,
    615,
    624,
    637,
    647,
    660,
    675,
    690,
    695,
    713,
    722,
    732,
    741,
    749,
    757,
    764,
    772,
    779,
    786,
    793,
    800,
    809,
    818,
    827,
    841,
    855,
    866,
    875,
    887,
    896,
    904,
    921,
    938,
    958,
    965,
    972,
    991,
    1010,
    1029,
    1048,
    1076,
    1104,
    1114,
    1129,
    1144,
    1164,
    1184,
    1201,
    1218,
    1244,
    1270,
    1293,
    1316,
    1334,
    1352,
    1368,
    1384,
    1397,
    1411,
    1427,
    1450,
    1464,
    1480,
    1500,
    1515,
    1534,
    1549,
    1562,
    1577,
    1592,
    1610,
    1628,
    1645,
    1659,
    1674,
    1684,
    1694,
    1705,
    1716,
    1730,
    1742,
    1753,
    1764,
    1782,
    1796,
    1813,
    1832,
    1850,
    1868,
    1879,
    1900,
    1921,
    1944,
    1967,
    1996,
    2014,
    2032,
    2044,
    2056,
    2067,
    2082,
    2101,
    2117,
    2136,
    2157,
    2178,
    2189,
    2213,
    2228,
    2244,
    2259,
    2273,
    2287,
    2300,
    2314,
    2327,
    2340,
    2353,
    2366,
    2381,
    2396,
    2411,
    2431,
    2451,
    2468,
    2483,
    2501,
    2516,
    2530,
    2553,
    2576,
    2602,
    2615,
    2628,
    2653,
    2678,
    2703,
    2728,
    2762,
};

ASSERT_VM_INSTRUCTION_SIZE(insn_name_info_offset);

static const char insn_name_info_base[2796] = ""
    "nop\0"
    "getlocal\0"
    "setlocal\0"
    "getblockparam\0"
    "setblockparam\0"
    "getspecial\0"
    "setspecial\0"
    "getinstancevariable\0"
    "setinstancevariable\0"
    "getclassvariable\0"
    "setclassvariable\0"
    "getconstant\0"
    "setconstant\0"
    "getglobal\0"
    "setglobal\0"
    "putnil\0"
    "putself\0"
    "putobject\0"
    "putspecialobject\0"
    "putiseq\0"
    "putstring\0"
    "concatstrings\0"
    "tostring\0"
    "freezestring\0"
    "toregexp\0"
    "intern\0"
    "newarray\0"
    "duparray\0"
    "expandarray\0"
    "concatarray\0"
    "splatarray\0"
    "newhash\0"
    "newrange\0"
    "pop\0"
    "dup\0"
    "dupn\0"
    "swap\0"
    "reverse\0"
    "reput\0"
    "topn\0"
    "setn\0"
    "adjuststack\0"
    "defined\0"
    "checkmatch\0"
    "checkkeyword\0"
    "tracebranch\0"
    "defineclass\0"
    "send\0"
    "opt_str_freeze\0"
    "opt_str_uminus\0"
    "opt_newarray_max\0"
    "opt_newarray_min\0"
    "opt_send_without_block\0"
    "invokesuper\0"
    "invokeblock\0"
    "leave\0"
    "throw\0"
    "jump\0"
    "branchif\0"
    "branchunless\0"
    "branchnil\0"
    "branchiftype\0"
    "getinlinecache\0"
    "setinlinecache\0"
    "once\0"
    "opt_case_dispatch\0"
    "opt_plus\0"
    "opt_minus\0"
    "opt_mult\0"
    "opt_div\0"
    "opt_mod\0"
    "opt_eq\0"
    "opt_neq\0"
    "opt_lt\0"
    "opt_le\0"
    "opt_gt\0"
    "opt_ge\0"
    "opt_ltlt\0"
    "opt_aref\0"
    "opt_aset\0"
    "opt_aset_with\0"
    "opt_aref_with\0"
    "opt_length\0"
    "opt_size\0"
    "opt_empty_p\0"
    "opt_succ\0"
    "opt_not\0"
    "opt_regexpmatch1\0"
    "opt_regexpmatch2\0"
    "opt_call_c_function\0"
    "bitblt\0"
    "answer\0"
    "getlocal_OP__WC__0\0"
    "getlocal_OP__WC__1\0"
    "setlocal_OP__WC__0\0"
    "setlocal_OP__WC__1\0"
    "putobject_OP_INT2FIX_O_0_C_\0"
    "putobject_OP_INT2FIX_O_1_C_\0"
    "trace_nop\0"
    "trace_getlocal\0"
    "trace_setlocal\0"
    "trace_getblockparam\0"
    "trace_setblockparam\0"
    "trace_getspecial\0"
    "trace_setspecial\0"
    "trace_getinstancevariable\0"
    "trace_setinstancevariable\0"
    "trace_getclassvariable\0"
    "trace_setclassvariable\0"
    "trace_getconstant\0"
    "trace_setconstant\0"
    "trace_getglobal\0"
    "trace_setglobal\0"
    "trace_putnil\0"
    "trace_putself\0"
    "trace_putobject\0"
    "trace_putspecialobject\0"
    "trace_putiseq\0"
    "trace_putstring\0"
    "trace_concatstrings\0"
    "trace_tostring\0"
    "trace_freezestring\0"
    "trace_toregexp\0"
    "trace_intern\0"
    "trace_newarray\0"
    "trace_duparray\0"
    "trace_expandarray\0"
    "trace_concatarray\0"
    "trace_splatarray\0"
    "trace_newhash\0"
    "trace_newrange\0"
    "trace_pop\0"
    "trace_dup\0"
    "trace_dupn\0"
    "trace_swap\0"
    "trace_reverse\0"
    "trace_reput\0"
    "trace_topn\0"
    "trace_setn\0"
    "trace_adjuststack\0"
    "trace_defined\0"
    "trace_checkmatch\0"
    "trace_checkkeyword\0"
    "trace_tracebranch\0"
    "trace_defineclass\0"
    "trace_send\0"
    "trace_opt_str_freeze\0"
    "trace_opt_str_uminus\0"
    "trace_opt_newarray_max\0"
    "trace_opt_newarray_min\0"
    "trace_opt_send_without_block\0"
    "trace_invokesuper\0"
    "trace_invokeblock\0"
    "trace_leave\0"
    "trace_throw\0"
    "trace_jump\0"
    "trace_branchif\0"
    "trace_branchunless\0"
    "trace_branchnil\0"
    "trace_branchiftype\0"
    "trace_getinlinecache\0"
    "trace_setinlinecache\0"
    "trace_once\0"
    "trace_opt_case_dispatch\0"
    "trace_opt_plus\0"
    "trace_opt_minus\0"
    "trace_opt_mult\0"
    "trace_opt_div\0"
    "trace_opt_mod\0"
    "trace_opt_eq\0"
    "trace_opt_neq\0"
    "trace_opt_lt\0"
    "trace_opt_le\0"
    "trace_opt_gt\0"
    "trace_opt_ge\0"
    "trace_opt_ltlt\0"
    "trace_opt_aref\0"
    "trace_opt_aset\0"
    "trace_opt_aset_with\0"
    "trace_opt_aref_with\0"
    "trace_opt_length\0"
    "trace_opt_size\0"
    "trace_opt_empty_p\0"
    "trace_opt_succ\0"
    "trace_opt_not\0"
    "trace_opt_regexpmatch1\0"
    "trace_opt_regexpmatch2\0"
    "trace_opt_call_c_function\0"
    "trace_bitblt\0"
    "trace_answer\0"
    "trace_getlocal_OP__WC__0\0"
    "trace_getlocal_OP__WC__1\0"
    "trace_setlocal_OP__WC__0\0"
    "trace_setlocal_OP__WC__1\0"
    "trace_putobject_OP_INT2FIX_O_0_C_\0"
    "trace_putobject_OP_INT2FIX_O_1_C_\0"
;

#define insn_name_info insn_name_info_base+insn_name_info_offset

static const char insn_operand_info[][8] = {
    "\1""",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""NN",
    "\2""N",
    "\3""IK",
    "\3""IK",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""G",
    "\2""G",
    "\1""",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""S",
    "\2""V",
    "\2""N",
    "\1""",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""N",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""N",
    "\1""",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\2""N",
    "\2""N",
    "\4""NVV",
    "\2""N",
    "\3""LN",
    "\3""NV",
    "\4""ISN",
    "\4""CES",
    "\2""V",
    "\2""V",
    "\2""N",
    "\2""N",
    "\3""CE",
    "\4""CES",
    "\2""C",
    "\1""",
    "\2""N",
    "\2""O",
    "\2""O",
    "\2""O",
    "\2""O",
    "\3""NO",
    "\3""OK",
    "\2""K",
    "\3""SK",
    "\3""HO",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\5""CECE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\4""CEV",
    "\4""CEV",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\2""V",
    "\3""CE",
    "\2""F",
    "\1""",
    "\1""",
    "\2""L",
    "\2""L",
    "\2""L",
    "\2""L",
    "\1""",
    "\1""",
    "\1""",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""NN",
    "\2""N",
    "\3""IK",
    "\3""IK",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""G",
    "\2""G",
    "\1""",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""S",
    "\2""V",
    "\2""N",
    "\1""",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""N",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""N",
    "\1""",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\2""N",
    "\2""N",
    "\4""NVV",
    "\2""N",
    "\3""LN",
    "\3""NV",
    "\4""ISN",
    "\4""CES",
    "\2""V",
    "\2""V",
    "\2""N",
    "\2""N",
    "\3""CE",
    "\4""CES",
    "\2""C",
    "\1""",
    "\2""N",
    "\2""O",
    "\2""O",
    "\2""O",
    "\2""O",
    "\3""NO",
    "\3""OK",
    "\2""K",
    "\3""SK",
    "\3""HO",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\5""CECE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\4""CEV",
    "\4""CEV",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\2""V",
    "\3""CE",
    "\2""F",
    "\1""",
    "\1""",
    "\2""L",
    "\2""L",
    "\2""L",
    "\2""L",
    "\1""",
    "\1""",
};

ASSERT_VM_INSTRUCTION_SIZE(insn_operand_info);

#ifdef USE_INSN_RET_NUM
static const unsigned short insn_stack_push_num_info[] = {
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    2,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    2,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
};

ASSERT_VM_INSTRUCTION_SIZE(insn_stack_push_num_info);
#endif

#ifdef USE_INSN_STACK_INCREASE
static int
insn_stack_increase(int depth, int insn, VALUE *opes)
{
    switch (insn) {
      case BIN(nop): {
	return depth + 0;
      }
      case BIN(getlocal): {
	return depth + 1;
      }
      case BIN(setlocal): {
	return depth + -1;
      }
      case BIN(getblockparam): {
	return depth + 1;
      }
      case BIN(setblockparam): {
	return depth + -1;
      }
      case BIN(getspecial): {
	return depth + 1;
      }
      case BIN(setspecial): {
	return depth + -1;
      }
      case BIN(getinstancevariable): {
	return depth + 1;
      }
      case BIN(setinstancevariable): {
	return depth + -1;
      }
      case BIN(getclassvariable): {
	return depth + 1;
      }
      case BIN(setclassvariable): {
	return depth + -1;
      }
      case BIN(getconstant): {
	return depth + 0;
      }
      case BIN(setconstant): {
	return depth + -2;
      }
      case BIN(getglobal): {
	return depth + 1;
      }
      case BIN(setglobal): {
	return depth + -1;
      }
      case BIN(putnil): {
	return depth + 1;
      }
      case BIN(putself): {
	return depth + 1;
      }
      case BIN(putobject): {
	return depth + 1;
      }
      case BIN(putspecialobject): {
	return depth + 1;
      }
      case BIN(putiseq): {
	return depth + 1;
      }
      case BIN(putstring): {
	return depth + 1;
      }
      case BIN(concatstrings): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(tostring): {
	return depth + -1;
      }
      case BIN(freezestring): {
	return depth + 0;
      }
      case BIN(toregexp): {
	int inc = 0;
        int cnt = FIX2INT(opes[1]);
        inc += 1 - cnt;;
        return depth + inc;
      }
      case BIN(intern): {
	return depth + 0;
      }
      case BIN(newarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(duparray): {
	return depth + 1;
      }
      case BIN(expandarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        int flag = FIX2INT(opes[1]);
        inc += num - 1 + (flag & 1 ? 1 : 0);;
        return depth + inc;
      }
      case BIN(concatarray): {
	return depth + -1;
      }
      case BIN(splatarray): {
	return depth + 0;
      }
      case BIN(newhash): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(newrange): {
	return depth + -1;
      }
      case BIN(pop): {
	return depth + -1;
      }
      case BIN(dup): {
	return depth + 1;
      }
      case BIN(dupn): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc += n;;
        return depth + inc;
      }
      case BIN(swap): {
	return depth + 0;
      }
      case BIN(reverse): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(reput): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(topn): {
	int inc = 0;
        inc += 1;;
        return depth + inc;
      }
      case BIN(setn): {
	int inc = 0;
        inc += 0;
        return depth + inc;
      }
      case BIN(adjuststack): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc -= n;
        return depth + inc;
      }
      case BIN(defined): {
	return depth + 0;
      }
      case BIN(checkmatch): {
	return depth + -1;
      }
      case BIN(checkkeyword): {
	return depth + 1;
      }
      case BIN(tracebranch): {
	return depth + 0;
      }
      case BIN(defineclass): {
	return depth + -1;
      }
      case BIN(send): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(opt_str_freeze): {
	return depth + 1;
      }
      case BIN(opt_str_uminus): {
	return depth + 1;
      }
      case BIN(opt_newarray_max): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(opt_newarray_min): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(opt_send_without_block): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += -ci->orig_argc;;
        return depth + inc;
      }
      case BIN(invokesuper): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(invokeblock): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += 1 - ci->orig_argc;;
        return depth + inc;
      }
      case BIN(leave): {
	return depth + 0;
      }
      case BIN(throw): {
	return depth + 0;
      }
      case BIN(jump): {
	return depth + 0;
      }
      case BIN(branchif): {
	return depth + -1;
      }
      case BIN(branchunless): {
	return depth + -1;
      }
      case BIN(branchnil): {
	return depth + -1;
      }
      case BIN(branchiftype): {
	return depth + -1;
      }
      case BIN(getinlinecache): {
	return depth + 1;
      }
      case BIN(setinlinecache): {
	return depth + 0;
      }
      case BIN(once): {
	return depth + 1;
      }
      case BIN(opt_case_dispatch): {
	int inc = 0;
        inc += -1;;
        return depth + inc;
      }
      case BIN(opt_plus): {
	return depth + -1;
      }
      case BIN(opt_minus): {
	return depth + -1;
      }
      case BIN(opt_mult): {
	return depth + -1;
      }
      case BIN(opt_div): {
	return depth + -1;
      }
      case BIN(opt_mod): {
	return depth + -1;
      }
      case BIN(opt_eq): {
	return depth + -1;
      }
      case BIN(opt_neq): {
	return depth + -1;
      }
      case BIN(opt_lt): {
	return depth + -1;
      }
      case BIN(opt_le): {
	return depth + -1;
      }
      case BIN(opt_gt): {
	return depth + -1;
      }
      case BIN(opt_ge): {
	return depth + -1;
      }
      case BIN(opt_ltlt): {
	return depth + -1;
      }
      case BIN(opt_aref): {
	return depth + -1;
      }
      case BIN(opt_aset): {
	return depth + -2;
      }
      case BIN(opt_aset_with): {
	return depth + -1;
      }
      case BIN(opt_aref_with): {
	return depth + 0;
      }
      case BIN(opt_length): {
	return depth + 0;
      }
      case BIN(opt_size): {
	return depth + 0;
      }
      case BIN(opt_empty_p): {
	return depth + 0;
      }
      case BIN(opt_succ): {
	return depth + 0;
      }
      case BIN(opt_not): {
	return depth + 0;
      }
      case BIN(opt_regexpmatch1): {
	return depth + 0;
      }
      case BIN(opt_regexpmatch2): {
	return depth + -1;
      }
      case BIN(opt_call_c_function): {
	return depth + 0;
      }
      case BIN(bitblt): {
	return depth + 1;
      }
      case BIN(answer): {
	return depth + 1;
      }
      case BIN(getlocal_OP__WC__0): {
	return depth + 1;
      }
      case BIN(getlocal_OP__WC__1): {
	return depth + 1;
      }
      case BIN(setlocal_OP__WC__0): {
	return depth + -1;
      }
      case BIN(setlocal_OP__WC__1): {
	return depth + -1;
      }
      case BIN(putobject_OP_INT2FIX_O_0_C_): {
	return depth + 1;
      }
      case BIN(putobject_OP_INT2FIX_O_1_C_): {
	return depth + 1;
      }
      case BIN(trace_nop): {
	return depth + 0;
      }
      case BIN(trace_getlocal): {
	return depth + 1;
      }
      case BIN(trace_setlocal): {
	return depth + -1;
      }
      case BIN(trace_getblockparam): {
	return depth + 1;
      }
      case BIN(trace_setblockparam): {
	return depth + -1;
      }
      case BIN(trace_getspecial): {
	return depth + 1;
      }
      case BIN(trace_setspecial): {
	return depth + -1;
      }
      case BIN(trace_getinstancevariable): {
	return depth + 1;
      }
      case BIN(trace_setinstancevariable): {
	return depth + -1;
      }
      case BIN(trace_getclassvariable): {
	return depth + 1;
      }
      case BIN(trace_setclassvariable): {
	return depth + -1;
      }
      case BIN(trace_getconstant): {
	return depth + 0;
      }
      case BIN(trace_setconstant): {
	return depth + -2;
      }
      case BIN(trace_getglobal): {
	return depth + 1;
      }
      case BIN(trace_setglobal): {
	return depth + -1;
      }
      case BIN(trace_putnil): {
	return depth + 1;
      }
      case BIN(trace_putself): {
	return depth + 1;
      }
      case BIN(trace_putobject): {
	return depth + 1;
      }
      case BIN(trace_putspecialobject): {
	return depth + 1;
      }
      case BIN(trace_putiseq): {
	return depth + 1;
      }
      case BIN(trace_putstring): {
	return depth + 1;
      }
      case BIN(trace_concatstrings): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_tostring): {
	return depth + -1;
      }
      case BIN(trace_freezestring): {
	return depth + 0;
      }
      case BIN(trace_toregexp): {
	int inc = 0;
        int cnt = FIX2INT(opes[1]);
        inc += 1 - cnt;;
        return depth + inc;
      }
      case BIN(trace_intern): {
	return depth + 0;
      }
      case BIN(trace_newarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_duparray): {
	return depth + 1;
      }
      case BIN(trace_expandarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        int flag = FIX2INT(opes[1]);
        inc += num - 1 + (flag & 1 ? 1 : 0);;
        return depth + inc;
      }
      case BIN(trace_concatarray): {
	return depth + -1;
      }
      case BIN(trace_splatarray): {
	return depth + 0;
      }
      case BIN(trace_newhash): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_newrange): {
	return depth + -1;
      }
      case BIN(trace_pop): {
	return depth + -1;
      }
      case BIN(trace_dup): {
	return depth + 1;
      }
      case BIN(trace_dupn): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc += n;;
        return depth + inc;
      }
      case BIN(trace_swap): {
	return depth + 0;
      }
      case BIN(trace_reverse): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(trace_reput): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(trace_topn): {
	int inc = 0;
        inc += 1;;
        return depth + inc;
      }
      case BIN(trace_setn): {
	int inc = 0;
        inc += 0;
        return depth + inc;
      }
      case BIN(trace_adjuststack): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc -= n;
        return depth + inc;
      }
      case BIN(trace_defined): {
	return depth + 0;
      }
      case BIN(trace_checkmatch): {
	return depth + -1;
      }
      case BIN(trace_checkkeyword): {
	return depth + 1;
      }
      case BIN(trace_tracebranch): {
	return depth + 0;
      }
      case BIN(trace_defineclass): {
	return depth + -1;
      }
      case BIN(trace_send): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(trace_opt_str_freeze): {
	return depth + 1;
      }
      case BIN(trace_opt_str_uminus): {
	return depth + 1;
      }
      case BIN(trace_opt_newarray_max): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_opt_newarray_min): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_opt_send_without_block): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += -ci->orig_argc;;
        return depth + inc;
      }
      case BIN(trace_invokesuper): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(trace_invokeblock): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += 1 - ci->orig_argc;;
        return depth + inc;
      }
      case BIN(trace_leave): {
	return depth + 0;
      }
      case BIN(trace_throw): {
	return depth + 0;
      }
      case BIN(trace_jump): {
	return depth + 0;
      }
      case BIN(trace_branchif): {
	return depth + -1;
      }
      case BIN(trace_branchunless): {
	return depth + -1;
      }
      case BIN(trace_branchnil): {
	return depth + -1;
      }
      case BIN(trace_branchiftype): {
	return depth + -1;
      }
      case BIN(trace_getinlinecache): {
	return depth + 1;
      }
      case BIN(trace_setinlinecache): {
	return depth + 0;
      }
      case BIN(trace_once): {
	return depth + 1;
      }
      case BIN(trace_opt_case_dispatch): {
	int inc = 0;
        inc += -1;;
        return depth + inc;
      }
      case BIN(trace_opt_plus): {
	return depth + -1;
      }
      case BIN(trace_opt_minus): {
	return depth + -1;
      }
      case BIN(trace_opt_mult): {
	return depth + -1;
      }
      case BIN(trace_opt_div): {
	return depth + -1;
      }
      case BIN(trace_opt_mod): {
	return depth + -1;
      }
      case BIN(trace_opt_eq): {
	return depth + -1;
      }
      case BIN(trace_opt_neq): {
	return depth + -1;
      }
      case BIN(trace_opt_lt): {
	return depth + -1;
      }
      case BIN(trace_opt_le): {
	return depth + -1;
      }
      case BIN(trace_opt_gt): {
	return depth + -1;
      }
      case BIN(trace_opt_ge): {
	return depth + -1;
      }
      case BIN(trace_opt_ltlt): {
	return depth + -1;
      }
      case BIN(trace_opt_aref): {
	return depth + -1;
      }
      case BIN(trace_opt_aset): {
	return depth + -2;
      }
      case BIN(trace_opt_aset_with): {
	return depth + -1;
      }
      case BIN(trace_opt_aref_with): {
	return depth + 0;
      }
      case BIN(trace_opt_length): {
	return depth + 0;
      }
      case BIN(trace_opt_size): {
	return depth + 0;
      }
      case BIN(trace_opt_empty_p): {
	return depth + 0;
      }
      case BIN(trace_opt_succ): {
	return depth + 0;
      }
      case BIN(trace_opt_not): {
	return depth + 0;
      }
      case BIN(trace_opt_regexpmatch1): {
	return depth + 0;
      }
      case BIN(trace_opt_regexpmatch2): {
	return depth + -1;
      }
      case BIN(trace_opt_call_c_function): {
	return depth + 0;
      }
      case BIN(trace_bitblt): {
	return depth + 1;
      }
      case BIN(trace_answer): {
	return depth + 1;
      }
      case BIN(trace_getlocal_OP__WC__0): {
	return depth + 1;
      }
      case BIN(trace_getlocal_OP__WC__1): {
	return depth + 1;
      }
      case BIN(trace_setlocal_OP__WC__0): {
	return depth + -1;
      }
      case BIN(trace_setlocal_OP__WC__1): {
	return depth + -1;
      }
      case BIN(trace_putobject_OP_INT2FIX_O_0_C_): {
	return depth + 1;
      }
      case BIN(trace_putobject_OP_INT2FIX_O_1_C_): {
	return depth + 1;
      }
      default:
	rb_bug("insn_sp_increase: unreachable");
    }
    return 0;
}
#endif

/* some utilities */

static int
insn_len(VALUE insn)
{
    return (unsigned char)insn_operand_info[(int)insn][0];
}

static const char *
insn_name(VALUE insn)
{
    return insn_name_info[(int)insn];
}

static const char *
insn_op_types(VALUE insn)
{
    return insn_operand_info[(int)insn]+1;
}

static int
insn_op_type(VALUE insn, long pos)
{
    int len = insn_len(insn) - 1;
    if (pos < len) {
	return insn_operand_info[(int)insn][pos+1];
    }
    else{
	return 0;
    }
}

#ifdef USE_INSN_RET_NUM
static int
insn_ret_num(VALUE insn)
{
    return insn_stack_push_num_info[(int)insn];
}
#endif
